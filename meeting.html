<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Convox Elite - Meeting</title>
  <script src="https://kit.fontawesome.com/a7b1b11b13.js" crossorigin="anonymous"></script>
  <script src="/socket.io/socket.io.js"></script> <!-- served by your node server -->
  <style>
    :root {
      --bg: #0f1720;
      --panel: #111827;
      --muted: #9ca3af;
      --accent: #3498db;
      --danger: #e53e3e;
      --card: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, var(--bg), #071027);
      color: #e6eef8;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header.nav {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 20px;
      background: rgba(0,0,0,0.25);
      border-bottom: 1px solid rgba(255,255,255,0.03);
      flex-shrink:0;
    }
    header .brand { font-size: 1.25rem; font-weight:700; display:flex; gap:8px; align-items:center; }
    .layout { display:flex; flex:1; min-height:0; } /* min-height:0 so children can scroll */
    main.video-area {
      flex:1;
      padding:16px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .meeting-info { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    .meeting-title { font-weight:700; font-size:1.1rem; }
    .meeting-meta { color:var(--muted); font-size:0.9rem; display:flex; gap:10px; align-items:center; }
    .grid {
      display:grid;
      grid-template-columns: repeat(auto-fit,minmax(280px,1fr));
      gap:12px;
      align-items: stretch;
    }
    .video-card {
      background: var(--card);
      border-radius:10px;
      overflow:hidden;
      position:relative;
      height:0;
      padding-bottom:56.25%; /* 16:9 */
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .video-card video {
      position:absolute;
      width:100%;
      height:100%;
      object-fit:cover;
      left:0; top:0;
      background:#000;
    }
    .name-tag {
      position:absolute;
      left:10px;
      bottom:10px;
      background:rgba(0,0,0,0.5);
      color:#fff;
      padding:4px 8px;
      border-radius:6px;
      font-weight:600;
      font-size:0.85rem;
      display:flex;
      gap:8px;
      align-items:center;
    }
    aside.sidebar {
      width:320px;
      background:var(--panel);
      border-left:1px solid rgba(255,255,255,0.03);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      flex-shrink:0;
    }
    .section-title { font-size:0.95rem; font-weight:700; margin-bottom:6px; }
    ul.participants { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px;}
    li.participant { display:flex; gap:8px; align-items:center; padding:8px; border-radius:8px; background:rgba(0,0,0,0.2); }
    .p-avatar { width:36px; height:36px; border-radius:50%; background:linear-gradient(135deg,#334155,#0ea5a4); display:flex; align-items:center; justify-content:center; font-weight:700; color:#fff; }
    .p-info { font-size:0.9rem; color:#e6eef8; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .controls {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      display:flex;
      gap:10px;
      z-index:2000;
      padding:10px 14px;
      background:rgba(0,0,0,0.4);
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(6px);
    }
    .controls button {
      width:58px; height:58px; border-radius:50%; border:none; cursor:pointer; display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px;
      background:#374151;
    }
    .controls button.primary { background:var(--accent); box-shadow:0 6px 18px rgba(52,152,219,0.12);}
    .controls button.danger { background:var(--danger); }
    .controls .label { display:block; font-size:11px; margin-top:6px; text-align:center; color:var(--muted); }
    .debug {
      position:fixed; right:12px; top:12px; background:rgba(0,0,0,0.6); padding:8px 10px; border-radius:8px; font-size:13px; color:var(--muted);
    }
    @media (max-width:900px) {
      aside.sidebar { width: 100%; height:220px; position:relative; order:2; }
      .layout { flex-direction:column; }
      main.video-area { order:1; padding-bottom:220px; }
      .controls { left:12px; transform:none; bottom:12px; }
    }
  </style>
</head>
<body>
  <header class="nav">
    <div class="brand"><i class="fas fa-video"></i> Convox Elite</div>
    <div>
      <span id="meeting-id-display" style="color:var(--muted); margin-right:12px">Meeting: N/A</span>
      <button id="copy-link" style="background:none;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:6px;cursor:pointer">Copy Link</button>
    </div>
  </header>

  <div class="layout">
    <main class="video-area">
      <div class="meeting-info">
        <div class="meeting-title">Live Meeting</div>
        <div class="meeting-meta">
          <div id="local-status">Not joined</div>
        </div>
      </div>

      <div class="grid" id="video-grid">
        <!-- video cards appended here -->
      </div>
    </main>

    <aside class="sidebar">
      <div>
        <div class="section-title">Participants</div>
        <ul class="participants" id="participants-list"></ul>
      </div>

      <div style="margin-top:auto">
        <div class="section-title">Chat</div>
        <div id="chat-box" style="height:200px; overflow:auto; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px;"></div>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <input id="chat-input" placeholder="Message..." style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); background:transparent; color:inherit">
          <button id="send-chat" style="padding:8px 12px; border-radius:8px; border:none; background:var(--accent); color:#fff; cursor:pointer">Send</button>
        </div>
      </div>
    </aside>
  </div>

  <div class="controls" aria-label="meeting controls">
    <button id="toggle-audio" title="Toggle mic"><i class="fas fa-microphone"></i></button>
    <button id="toggle-video" title="Toggle video"><i class="fas fa-video"></i></button>
    <button id="share-screen" title="Share screen"><i class="fas fa-desktop"></i></button>
    <button id="start-record" title="Start recording"><i class="fas fa-circle"></i></button>
    <button id="stop-record" title="Stop recording" style="display:none;"><i class="fas fa-stop"></i></button>
    <button id="leave" class="danger" title="Leave"><i class="fas fa-phone-slash"></i></button>
  </div>

  <div class="debug" id="debug">Initializing...</div>

<script>
/* ---------------------
  Configuration & state
   --------------------- */
const SIGNALING_BASE = window.location.origin; // expects your Node server to serve socket.io at same origin
const socket = io(SIGNALING_BASE, { autoConnect: false }); // connect after we fetch meeting details
const urlParams = new URLSearchParams(window.location.search);
const MEETING_ID = urlParams.get('id');
const localName = localStorage.getItem('userName') || 'Guest';
const localEmail = localStorage.getItem('userEmail') || `guest-${Math.random().toString(36).slice(2,8)}@example.com`;

const videoGrid = document.getElementById('video-grid');
const participantsList = document.getElementById('participants-list');
const debug = document.getElementById('debug');
const meetingIdDisplay = document.getElementById('meeting-id-display');
meetingIdDisplay.textContent = `Meeting: ${MEETING_ID || 'N/A'}`;

let localStream = null;
let originalVideoTrack = null;
let screenStream = null;
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;

const peers = {}; // socketId -> RTCPeerConnection
const participants = {}; // socketId -> { name, email }

/* Default ICE servers fallback */
let ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' }
];

/* UI elements */
const btnAudio = document.getElementById('toggle-audio');
const btnVideo = document.getElementById('toggle-video');
const btnShare = document.getElementById('share-screen');
const btnStartRecord = document.getElementById('start-record');
const btnStopRecord = document.getElementById('stop-record');
const btnLeave = document.getElementById('leave');
const localStatus = document.getElementById('local-status');
const copyLink = document.getElementById('copy-link');
const chatBox = document.getElementById('chat-box');
const chatInput = document.getElementById('chat-input');
const sendChat = document.getElementById('send-chat');

/* ---------------------
  Helpers: UI creation
   --------------------- */
function createVideoCard(id, label, muted = false) {
  // id used to compose DOM ids
  const card = document.createElement('div');
  card.className = 'video-card';
  card.id = `container-${id}`;

  const video = document.createElement('video');
  video.id = `video-${id}`;
  video.autoplay = true;
  video.playsInline = true;
  video.muted = muted;

  const tag = document.createElement('div');
  tag.className = 'name-tag';
  tag.textContent = label;

  card.appendChild(video);
  card.appendChild(tag);
  return { card, video, tag };
}

function addLocalPreview(stream) {
  const id = 'me-' + (Math.random().toString(36).slice(2,6));
  const { card, video, tag } = createVideoCard(id, `${localName} (You)`, true);
  video.srcObject = stream;
  video.addEventListener('loadedmetadata', ()=> video.play().catch(()=>{}));
  videoGrid.prepend(card);
}

function addRemoteStream(socketId, stream, name) {
  const containerId = `remote-${socketId}`;
  if (document.getElementById(`container-${containerId}`)) {
    const existingVideo = document.getElementById(`video-${containerId}`);
    existingVideo.srcObject = stream;
    return;
  }
  const { card, video, tag } = createVideoCard(containerId, name || 'Guest', false);
  video.srcObject = stream;
  video.addEventListener('loadedmetadata', ()=> video.play().catch(()=>{}));
  videoGrid.appendChild(card);
}

function removeRemoteVideo(socketId) {
  const containerId = `container-remote-${socketId}`;
  const el = document.getElementById(containerId);
  if (el) el.remove();
}

/* Participants list UI */
function renderParticipants() {
  participantsList.innerHTML = '';
  // Include local user first
  const liYou = document.createElement('li');
  liYou.className = 'participant';
  liYou.innerHTML = `<div class="p-avatar"> ${localName[0] || 'Y'} </div><div class="p-info">${localName} <small style="color:var(--muted)"> (You)</small></div>`;
  participantsList.appendChild(liYou);

  Object.entries(participants).forEach(([socketId, info]) => {
    const li = document.createElement('li');
    li.className = 'participant';
    li.id = `participant-${socketId}`;
    li.innerHTML = `<div class="p-avatar">${(info.name||'G')[0]}</div><div class="p-info">${info.name || 'Guest'}<div style="font-size:12px;color:var(--muted)">${info.email || ''}</div></div>`;
    participantsList.appendChild(li);
  });
}

/* Chat functions */
function appendChat(sender, message, me=false) {
  const d = document.createElement('div');
  d.style.marginBottom='8px';
  d.innerHTML = `<strong style="color:${me ? '#9be7ff' : '#fff'}">${me ? 'You' : sender}</strong><div style="color:var(--muted);font-size:0.95rem">${escapeHtml(message)}</div>`;
  chatBox.appendChild(d);
  chatBox.scrollTop = chatBox.scrollHeight;
}
function escapeHtml(s){ return s.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* -------------------------
   Networking: fetch ICE then connect socket
   ------------------------- */
async function init() {
  if (!MEETING_ID) {
    alert('Missing meeting id in URL. Use ?id=<meetingId>');
    return;
  }
  debug.textContent = 'Fetching meeting config...';

  try {
    // ask server for meeting & ICE servers
    const resp = await fetch(`${SIGNALING_BASE}/join-meeting`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ meetingId: MEETING_ID })
    });
    if (!resp.ok) {
      const body = await resp.json().catch(()=>({}));
      debug.textContent = 'Meeting not found. Redirect or create meeting first.';
      alert('Meeting not found on server. Create one first.');
      return;
    }
    const body = await resp.json();
    if (body.iceServers) ICE_SERVERS = body.iceServers;

    debug.textContent = 'Connecting to signaling server...';
    socket.io.opts.transports = ['websocket', 'polling'];
    socket.connect();

    // set meeting display
    meetingIdDisplay.textContent = `Meeting: ${MEETING_ID}`;

    setupSocketHandlers();

    // start local media by default
    await startLocalMedia();
    localStatus.textContent = 'Joined â€” ready';
  } catch (err) {
    console.error(err);
    debug.textContent = 'Failed to initialize. See console.';
  }
}

/* -------------------------
   WebRTC peer management
   ------------------------- */
function createPeerConnection(targetSocketId) {
  if (peers[targetSocketId]) return peers[targetSocketId];

  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  peers[targetSocketId] = pc;

  // Add local tracks
  if (localStream) {
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
  }

  // When remote track arrives
  pc.ontrack = (ev) => {
    const [stream] = ev.streams;
    addRemoteStream(targetSocketId, stream, participants[targetSocketId]?.name || 'Guest');
  };

  pc.onicecandidate = (ev) => {
    if (ev.candidate) {
      socket.emit('ice-candidate', { candidate: ev.candidate, toSocketId: targetSocketId });
    }
  };

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed') {
      // cleanup
      try { pc.close(); } catch(e){}
      delete peers[targetSocketId];
      removeRemoteVideo(targetSocketId);
      delete participants[targetSocketId];
      renderParticipants();
    }
  };

  return pc;
}

async function replaceVideoTrack(newTrack) {
  // replace for all peers
  for (const p of Object.values(peers)) {
    try {
      const sender = p.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) await sender.replaceTrack(newTrack);
    } catch (e) { console.warn('replace track failed', e); }
  }
}

/* -------------------------
   Socket handlers (signaling)
   ------------------------- */
function setupSocketHandlers() {
  socket.on('connect', ()=> {
    debug.textContent = 'Connected to signaling server.';
    // join-room after connect
    socket.emit('join-room', { meetingId: MEETING_ID, name: localName, email: localEmail });
  });

  socket.on('existing-participants', async (existing) => {
    // existing: array of {name, email, socketId}
    debug.textContent = `Found ${existing.length} participant(s). Establishing calls...`;
    existing.forEach(p => {
      participants[p.socketId] = { name: p.name, email: p.email };
    });
    renderParticipants();

    // create offers to each existing participant
    for (const p of existing) {
      try {
        const pc = createPeerConnection(p.socketId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('call-user', { offer, toSocketId: p.socketId });
        console.log('Sent offer to', p.socketId);
      } catch (err) {
        console.error('Offer error', err);
      }
    }
  });

  socket.on('user-connected', (user) => {
    // someone new joined (we will receive incoming call when they create offer, or we will create offer if we are the joining party's existing participants)
    debug.textContent = `${user.name || 'A user'} joined`;
    participants[user.socketId] = { name: user.name, email: user.email };
    renderParticipants();
  });

  socket.on('incoming-call', async ({ offer, from, fromName }) => {
    console.log(`Incoming call from ${fromName} (${from})`);
    participants[from] = participants[from] || { name: fromName };
    renderParticipants();

    const pc = createPeerConnection(from);
    try {
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit('make-answer', { answer, toSocketId: from });
      console.log('Sent answer to', from);
    } catch (err) {
      console.error('incoming-call handling error', err);
    }
  });

  socket.on('answer-made', async ({ answer, from }) => {
    const pc = peers[from];
    if (!pc) {
      console.warn('No peer for answer from', from);
      return;
    }
    try {
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      console.log('Answer set for', from);
    } catch (err) {
      console.error('Error setting remote description (answer-made)', err);
    }
  });

  socket.on('ice-candidate', async ({ candidate, from }) => {
    const pc = peers[from];
    if (!pc) return;
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (e) {
      console.warn('Failed to add ice candidate', e);
    }
  });

  socket.on('chat-message', ({ senderName, message }) => {
    appendChat(senderName, message);
  });

  socket.on('user-disconnected', ({ socketId }) => {
    console.log('User disconnected', socketId);
    if (peers[socketId]) {
      try { peers[socketId].close(); } catch(e){}
      delete peers[socketId];
    }
    delete participants[socketId];
    removeRemoteVideo(socketId);
    renderParticipants();
  });

  socket.on('connect_error', (err) => {
    console.error('Socket connect_error', err);
    debug.textContent = 'Signaling connection failed.';
  });
}

/* -------------------------
   Local media & controls
   ------------------------- */
async function startLocalMedia() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio: true });
    originalVideoTrack = localStream.getVideoTracks()[0];
    addLocalPreview(localStream);
    localStatus.textContent = 'Camera & mic active';
    // add tracks to existing peers (if any)
    for (const pc of Object.values(peers)) {
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    }
  } catch (err) {
    console.error('Error getting local media', err);
    alert('Could not access camera/microphone. Make sure you granted permissions and are on HTTPS.');
    localStatus.textContent = 'No camera';
    throw err;
  }
}

/* toggle audio */
btnAudio.addEventListener('click', ()=> {
  if (!localStream) return;
  const t = localStream.getAudioTracks()[0];
  if (!t) return;
  t.enabled = !t.enabled;
  btnAudio.style.background = t.enabled ? '#374151' : '#dc2626';
});

/* toggle video */
btnVideo.addEventListener('click', ()=> {
  if (!localStream) return;
  const t = localStream.getVideoTracks()[0];
  if (!t) return;
  t.enabled = !t.enabled;
  btnVideo.style.background = t.enabled ? '#374151' : '#dc2626';
});

/* screen sharing */
btnShare.addEventListener('click', async ()=> {
  if (!localStream) {
    alert('Start meeting (camera) first.');
    return;
  }
  if (screenStream) {
    // stop share
    screenStream.getTracks().forEach(t => t.stop());
    screenStream = null;
    // restore original video
    replaceVideoTrack(originalVideoTrack);
    btnShare.style.background = '#374151';
    // remove screen card
    const screenCard = document.querySelector('[data-screen="true"]');
    if (screenCard) screenCard.remove();
    return;
  }

  try {
    screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
    const screenTrack = screenStream.getVideoTracks()[0];

    // show a local screen preview card
    const id = 'screen-' + Math.random().toString(36).slice(2,6);
    const { card, video } = createVideoCard(id, 'You - Screen', true);
    card.dataset.screen = 'true';
    video.srcObject = screenStream;
    video.addEventListener('loadedmetadata', ()=> video.play().catch(()=>{}));
    videoGrid.prepend(card);

    // replace video track sent to peers
    await replaceVideoTrack(screenTrack);
    btnShare.style.background = '#065f46';

    // when user stops sharing
    screenTrack.onended = () => {
      if (screenStream) {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }
      // restore camera
      replaceVideoTrack(originalVideoTrack);
      btnShare.style.background = '#374151';
      const sc = document.querySelector('[data-screen="true"]');
      if (sc) sc.remove();
    };
  } catch (err) {
    console.error('Screen share failed', err);
    alert('Screen share canceled or not allowed.');
  }
});

/* Recording (combine local audio + camera and screen if any) */
btnStartRecord.addEventListener('click', ()=> {
  if (!localStream) { alert('Start meeting first.'); return; }
  if (isRecording) return;
  const tracks = [];
  // audio from localStream
  localStream.getAudioTracks().forEach(t => tracks.push(t));
  // video: prefer screen if present, else camera
  if (screenStream && screenStream.getVideoTracks().length) {
    screenStream.getVideoTracks().forEach(t => tracks.push(t));
  } else {
    localStream.getVideoTracks().forEach(t => tracks.push(t));
  }
  const combined = new MediaStream(tracks);
  recordedChunks = [];
  try {
    mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp8,opus' });
  } catch (e) {
    try { mediaRecorder = new MediaRecorder(combined); } catch (err) { alert('Recording not supported'); return; }
  }
  mediaRecorder.ondataavailable = (e) => { if (e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ConvoxRecording_${new Date().toISOString().replace(/[:.]/g,'-')}.webm`;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 10000);
    a.remove();
    isRecording = false;
    btnStartRecord.style.display = '';
    btnStopRecord.style.display = 'none';
  };
  mediaRecorder.start();
  isRecording = true;
  btnStartRecord.style.display = 'none';
  btnStopRecord.style.display = '';
});

/* stop recording */
btnStopRecord.addEventListener('click', ()=> {
  if (mediaRecorder && isRecording) {
    mediaRecorder.stop();
  }
});

/* leave meeting */
btnLeave.addEventListener('click', ()=> {
  // stop all local streams
  if (localStream) localStream.getTracks().forEach(t=>t.stop());
  if (screenStream) screenStream.getTracks().forEach(t=>t.stop());
  // close peers
  Object.values(peers).forEach(p => { try{ p.close(); } catch(e){} });
  // notify server
  socket.emit('leave-room', MEETING_ID);
  socket.disconnect();
  window.location.href = '/'; // or wherever
});

/* chat */
sendChat.addEventListener('click', ()=> {
  const t = chatInput.value.trim();
  if (!t) return;
  appendChat(localName, t, true);
  socket.emit('chat-message', { message: t, meetingId: MEETING_ID, senderName: localName });
  chatInput.value = '';
});
chatInput.addEventListener('keypress', (e)=> { if (e.key === 'Enter') sendChat.click(); });

/* copy link */
copyLink.addEventListener('click', ()=> {
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(()=> {
    copyLink.textContent = 'Copied!';
    setTimeout(()=> copyLink.textContent = 'Copy Link', 1500);
  });
});

/* start initialization */
init().then(()=> {
  debug.textContent = 'Ready';
}).catch(e => {
  debug.textContent = 'Init failed';
  console.error(e);
});

</script>
</body>
</html>
